---
title: Chiptune Player
slug: chiptune-player
status: done
startDate: 2025-09-15
endDate:
tags: [audio, synthesis, python, fastapi]
repo: https://github.com/dorlo1994/chiptune_player
demo: true
featured: true
relatedPosts:
---
## Overview
This is a chiptune synthesizer, originally built as part of a Hackathon in 2023. Its' main goal is to create audio waveforms directly from a list of notes. It is capable of playing any number of sin, square, sawtooth and triangle waves, while providing musical utility functions such as raising and lowering notes by given intervals and generating chords.

## Architecture
The engine is built in Python, and uses the `numpy` package to simplify some calculations.
### File Reader
`file_rader.py` provides note parsing functionality, both from files and strings, using the following Regular Expressions:
```python
from .music_utils import Note, Wave

DURATION_PATTERN = r'(?P<duration>\d+(?:\.\d+)?)'
READ_NOTE_PATTERN = fr'{Note.NAME_PATTERN}-{Wave.name_pattern()}-{DURATION_PATTERN}'
```
see [Music Utils](#music-utils) for relevant patterns.
Notes are stored in a `NoteSheet` object, which is passed to a `NotePlayer` object (see [Player](#player))
### Music Utils
This encompasses all Music Theory related calculations, including wave calculations. Before diving into the contents of `music_utils.py`, let's take a minute to introduce the relevant Math and Music Theory:
#### Music Theory and Wave Generation Primer
In Music Theory, notes have a **tone** and an **octave**. By tone, I mean the 12 tones scale used in western music, and by octave I mean the number of tone-cycles above the lowest possible notes. What we have, then, are notes such as `C4`, `Bb6`, `D#3`, etc. Notes are separated by **intervals**, with an octave being such an interval, one of 12 semitones. These, in turn, define **chords**, such as a major chord based on `C4`: `C4 E4 G4`. The interval between `E4` and `C4` is known as a **Major Third**, and between `G4` and `C4` we have a **Fifth**. `C4` is known as the chord's **root**, and if we were to chose `D4` as a root instead, the resulting major chord (D Major) is `D4 F#4 A5`.
To create actual sound from these notes, we calculate the sound wave generated by them directly. This requires two pieces of information: the waveform to play and the frequency to play it with.
Waves are **periodical functions in time**. By periodic we mean that after a certain amount of time, known as the **period**, the function repeats itself. Usually we don't use the period directly, but its' inverse which is defined as a wave's **frequency**, measured in **Hertz** (Hz), or Cycles per Seconds. For example, `A4` has a frequency of 440Hz, meaning it has 440 cycles per seconds. As for which wave function is used, this package provides a preset of **4** waveforms, commonly used in Chiptune music: sin, square, triangle and sawtooth.
`music_utils.py` provides data structures for Notes, Intervals and Waves, and defines their generation logic.
### Player
Given a `NoteSheet` object (see [File Reader](#file-reader)), a `NotePlayer` utilizes the functionality provided by the [Music Utils](#music-utils) to create actual bytes of wave data. To do this while not introducing new noise artefacts, the player keeps track of how long a note has been playing for each chunk of bytes generated, such that when generating the next chunk of bytes the correct section of the wave will be used. Otherwise, the "chunking" frequency may itself become the dominant one in the resulting signal.
### Server
The engine is revealed via a FastAPI `render` endpoint which accepts a structured list of notes, starting with an integer tempo, in BPM (Beats Per Minutes). Each line is also prefixed by the beat number it's specifying. Below is a demo which calls this endpoint to return a WAV file playing the notes written in the text box. Try it below!